From 2223a9a18169f62923cb79d6af57ceb4074100d9 Mon Sep 17 00:00:00 2001
From: =?utf8?q?R=C3=A9mi=20Denis-Courmont?= <remi@remlab.net>
Date: Thu, 25 Jun 2015 23:55:10 +0300
Subject: [PATCH] Fix atomics usage in C++

---
 modules/access/decklink.cpp        |  8 ++++----
 modules/video_filter/atmo/atmo.cpp | 10 +++++-----
 2 files changed, 9 insertions(+), 9 deletions(-)

diff --git a/modules/access/decklink.cpp b/modules/access/decklink.cpp
index 55c48b8f77..872a4bdaa7 100644
--- a/modules/access/decklink.cpp
+++ b/modules/access/decklink.cpp
@@ -213,19 +213,19 @@ class DeckLinkCaptureDelegate : public IDeckLinkInputCallback
 public:
     DeckLinkCaptureDelegate(demux_t *demux) : demux_(demux)
     {
-        atomic_store(&m_ref_, 1);
+        m_ref_.store(1);
     }
 
     virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID *) { return E_NOINTERFACE; }
 
     virtual ULONG STDMETHODCALLTYPE AddRef(void)
     {
-        return atomic_fetch_add(&m_ref_, 1);
+        return m_ref_.fetch_add(1);
     }
 
     virtual ULONG STDMETHODCALLTYPE Release(void)
     {
-        uintptr_t new_ref = atomic_fetch_sub(&m_ref_, 1);
+        uintptr_t new_ref = m_ref_.fetch_sub(1);
         if (new_ref == 0)
             delete this;
         return new_ref;
@@ -264,7 +264,7 @@ public:
     virtual HRESULT STDMETHODCALLTYPE VideoInputFrameArrived(IDeckLinkVideoInputFrame*, IDeckLinkAudioInputPacket*);
 
 private:
-    atomic_uint m_ref_;
+    std::atomic_uint m_ref_;
     demux_t *demux_;
 };
 
diff --git a/modules/video_filter/atmo/atmo.cpp b/modules/video_filter/atmo/atmo.cpp
index 4b1f1c8e6b..f899388e50 100644
--- a/modules/video_filter/atmo/atmo.cpp
+++ b/modules/video_filter/atmo/atmo.cpp
@@ -695,7 +695,7 @@ typedef struct
 {
     filter_t *p_filter;
     vlc_thread_t thread;
-    atomic_bool abort;
+    std::atomic_bool abort;
 
     /* tell the thread which color should be the target of fading */
     uint8_t ui_red;
@@ -1105,7 +1105,7 @@ static void Atmo_Shutdown(filter_t *p_filter)
           p_sys->p_fadethread->i_steps  = 1;
         else
           p_sys->p_fadethread->i_steps  = p_sys->i_endfadesteps;
-        atomic_store(&p_sys->p_fadethread->abort, false);
+        p_sys->p_fadethread->abort.store(false);
 
         if( vlc_clone( &p_sys->p_fadethread->thread,
                        FadeToColorThread,
@@ -2347,7 +2347,7 @@ static void *FadeToColorThread(void *obj)
             /* send the same pixel data again... to unlock the buffer! */
             AtmoSendPixelData( p_fadethread->p_filter );
 
-            while( (!atomic_load (&p_fadethread->abort)) &&
+            while( !p_fadethread->abort.load() &&
                 (i_steps_done < p_fadethread->i_steps))
             {
                 p_transfer = AtmoLockTransferBuffer( p_fadethread->p_filter );
@@ -2360,7 +2360,7 @@ static void *FadeToColorThread(void *obj)
                 thread improvements wellcome!
                 */
                 for(i_index = 0;
-                    (i_index < i_size) && (!atomic_load (&p_fadethread->abort));
+                    (i_index < i_size) && !p_fadethread->abort.load();
                     i_index+=4)
                 {
                     i_src_blue  = p_source[i_index+0];
@@ -2416,7 +2416,7 @@ static void CheckAndStopFadeThread(filter_t *p_filter)
     {
         msg_Dbg(p_filter, "kill still running fadeing thread...");
 
-        atomic_store(&p_sys->p_fadethread->abort, true);
+        p_sys->p_fadethread->abort.store(true);
 
         vlc_join(p_sys->p_fadethread->thread, NULL);
         free(p_sys->p_fadethread);
-- 
2.11.0

